$stderr.print %q{
This program generates ruby code to strip accents from characters in Latin and Greek scripts.
Progress will be printed to stderr, the final result to stdout.
}

all_characters = %q{
         ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÑÒÓÔÕÖØÙÚÛÜÝàáâãäåæçèéêëìíîïñòóôõöøùúûüýÿ
         ΆΈΊΌΐάέήίϊόύώỏἀἁἃἄἅἈἐἑἒἔἕἘἙἜἡἢἣἤἥἦἨἩἫἬἮἰἱἲἴἵἶἸὀὁὂὃὄὅὊὍὐὑὓὔὕὖὗὝὡὢὣὤὥὧὨὩὰὲὴὶὸὺὼᾐᾗᾳᾴᾶῂῆῇῖῥῦῳῶῷῸᾤᾷἂἷ
         ὌᾖὉἧἷἂῃἌὬὉἷὉἷῃὦἌἠἳᾔἉᾦἠἳᾔὠᾓὫἝὈἭἼϋὯῴἆῒῄΰῢἆὙὮᾧὮᾕὋἍἹῬἽᾕἓἯἾᾠἎῗἾῗἯἊὭἍᾑᾰῐῠᾱῑῡᾸῘῨᾹῙῩ
}.gsub(/\s/,'')
# The first line is a list of accented Latin characters. The second and third lines are polytonic Greek.
# The Greek on this list includes every character occurring in the Project Gutenberg editions of Homer, except for some that seem to be
# mistakes (smooth rho, phi and theta in symbol font). Duplications and characters out of order in this list have no effect at run time.
# Also includes vowels with macron and vrachy, which occur in Project Perseus texts sometimes.

# The following code shells out to the linux command-line utility called "unicode," which is installed as the debian package
# of the same name.
# Documentation: https://github.com/garabik/unicode/blob/master/README

def char_to_name(c)
  return `unicode --string "#{c}" --format "{name}"`.downcase
end

def name_to_char(name)
   if name=='greek small letter eta with dasia and oxia with ypogegrammeni' then name='greek small letter eta with dasia and oxia and ypogegrammeni' end
   if name=='greek small letter eta with oxia with ypogegrammeni' then name='greek small letter eta with oxia and ypogegrammeni' end
   name.gsub!(/\s+$/,'')
   name.gsub!(/oxiawith/,'oxia with') # why does this happen?
   list = `unicode "#{name}" --format "{pchar}" --max 0` # returns a string of possibilities, not just exact matches
   # Usually, but not always, the unaccented character is the first on the list.
   list.chars.each { |c|
     if char_to_name(c).downcase==name.downcase then return c end
   }
   raise "Unable to convert name #{name} to a character, list=#{list}."
end

whine = []
from = ''
to = ''
all_characters.chars.sort.uniq.each { |c|
  name = char_to_name(c)
  next unless name=~/(grave|varia)/
  name.gsub!(/(grave|varia)\s*/,'acute') # oxia=acute, dasia=rough, varia=grave, tonos=acute
  name.sub!(/and ypogegrammeni/,'with ypogegrammeni')
  1.upto(3) { |i|
    name.sub!(/with ([a-z]+) with ([a-z]+)/) { "with #{$1} and #{$2}" }
    name.sub!(/and ([a-z]+) with ([a-z]+)/) { "with #{$1} and #{$2}" }
  }
  try_again = false
  begin
    with_acute = name_to_char(name)
  rescue
    try_again = true
    name.sub!(/acute/,'oxia')
  end
  if try_again then
    begin
      with_acute = name_to_char(name)
    rescue
      whine.push(name)
      next
    end
  end
  if with_acute=='ὼ' then raise "name=#{name}" end
  if with_acute=='ὣ' then raise "name=#{name}" end
  from = from+c.unicode_normalize(:nfc)
  to = to+with_acute.unicode_normalize(:nfc)
  $stderr.print with_acute
}
$stderr.print "\n"
if whine.length>0 then $stderr.print "failed on the following:\n  "+whine.join("\n  ") end
print %Q{
# Code generated by grave_to_acute.rb
# See notes there on how to add characters to the list.
def grave_to_acute(s)
  return s.unicode_normalize(:nfc).tr("#{from}","#{to}")
end
}

